import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as a,o as n}from"./app-btP1-p7a.js";const l={};function e(h,i){return n(),t("div",null,i[0]||(i[0]=[a(`<h1 id="进程和线程" tabindex="-1"><a class="header-anchor" href="#进程和线程"><span>进程和线程</span></a></h1><p>进程是资源分配的基本单位。线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。</p><h2 id="windows进程相关" tabindex="-1"><a class="header-anchor" href="#windows进程相关"><span>windows进程相关</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BOOL</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> CreateProcess</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(  </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPCTSTR</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpApplicationName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 应用程序名称  </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPTSTR</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpCommandLine</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 命令行字符串  </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPSECURITY_ATTRIBUTES</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpProcessAttributes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 进程的安全属性 </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                         //ECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //typedef struct _SECURITY_ATTRIBUTES {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //    DWORD nLength; //结构体的大小，可用sizeof取得</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //    LPVOID lpSecurityDescriptor; //安全描述符</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //    BOOL bInheritHandle ;//安全描述的对象能否被新创建的进程继承</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //} SECURITY_ATTRIBUTES，* PSECURITY_ATTRIBUTES;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPSECURITY_ATTRIBUTES</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpThreadAttributes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 线程的安全属性，跟进程的安全属性一样，只不过这是线程的属性</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　BOOL</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> bInheritHandles</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 是否继承父进程的属性（父进程可继承的打开句柄）</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　DWORD</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> dwCreationFlags</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 创建标志 </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                         //CREATE_DEFAULT_ERROR_MODE:新的进程不继承调用进程的错误模式,默认的行为是为新进程继承调用者的错误模式(可以指定该标志修改）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //CREATE_NEW_CONSOLE：新的进程将使用一个新的控制台，而不是继承父进程的控制台。这个标志不能与DETACHED_PROCESS标志一起使用</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //CREATE_NEW_PROCESS_GROUP：新进程将是一个进程树的根进程。进程树中的全部进程都是根进程的子进程。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //CREATE_SEPARATE_WOW_VDM：DOS环境相关，现在无用途</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //CREATE_SHARED_WOW_VDM：DOS环境相关，现在无用途</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //CREATE_SUSPENDED：新进程的主线程会以暂停的状态被创建，直到调用ResumeThread函数被调用时才运行</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //CREATE_UNICODE_ENVIRONMENT：如果被设置，由lpEnvironment参数指定的环境块使用Unicode字符，如果为空，环境块使用ANSI字符</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //DEBUG_PROCESS：如果这个标志被设置，调用进程将被当做一个调试程序，并且新进程会被当做被调试的进程</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //DEBUG_ONLY_THIS_PROCESS：如果此标志没有被设置且调用进程正在被调试，新进程将成为调试调用进程的调试器的另一个调试对象</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //DETACHED_PROCESS：对于控制台进程，新进程没有访问父进程控制台的权限。新进程可以通过AllocConsole函数自己创建一个新的控制台。这个标志不可以与CREATE_NEW_CONSOLE标志一起使用。</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">						 //CREATE_NO_WINDOW：系统不为新进程创建CUI窗口，使用该标志可以创建不含窗口的CUI程序。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPVOID</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpEnvironment</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向新的环境块的指针，指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPCTSTR</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpCurrentDirectory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指向一个以NULL结尾的字符串，这个字符串用来指定子进程的工作路径。这个字符串必须是一个包含驱动器名的绝对路径。</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPSTARTUPINFO</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpStartupInfo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 传递给新进程的信息  </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">　LPPROCESS_INFORMATION</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> lpProcessInformation</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 新进程返回的信息  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（1）当我们双击一个程序test.exe运行的时候，一定是被另一个程序（Explorer.exe:桌面进程)调用了CreateProcess函数 打开的 （2）test.exe是PE文件，CreateProcess进入内核（NtCreateProcess），开始为test.exe创造运行条件，在内核空间分配4GB地址空间，首先创建一个句柄表（主要2项是传递给应用层的HANDLE和自己使用的一个指针，内核不允许用户进程直接操作这个指针，必须通过HANDLE传递，内核查表查出HANDLE对应的指针） （3）将test.exe拉伸，加载到指定位置（具体位置：根据ImageBase+EntryPoint加载到4GB地址空间） （4）加载导入表的DLL，以及DLL依赖的DLL（递归的） （5）修复（EXE和DLL的）IAT表 （6）创建线程、设置线程CONTEXT，设置CONTEXT的EIP为test.exe加载地址（ImageBase+EntryPoint），开始执行（这个可以看我的上一篇线程本质的文章）</p><p>（7）创建完成后，通过：PROCESS_INFORMATION返回信息：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> _PROCESS_INFORMATION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">					</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{					</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   HANDLE hProcess;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">				//进程句柄	</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   HANDLE hThread;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">				//主线程句柄	</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   DWORD dwProcessId;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">			//进程ID	</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">   DWORD dwThreadId;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">			//线程ID	</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">PROCESS_INFORMATION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="驱动" tabindex="-1"><a class="header-anchor" href="#驱动"><span>驱动</span></a></h2><p>https://docs.microsoft.com/zh-cn/windows-hardware/drivers/develop/getting-started-with-windows-drivers</p><p>当你编写驱动程序以在 Windows 操作系统上运行时，有两个基本选择。 可以编写 Windows 桌面驱动程序，该驱动程序仅在 Windows Desktop 版本上运行。 或者，你可以满足一些额外的要求，编写一个 Windows 驱动程序，该驱动程序在 Windows 的桌面版和非桌面版变体上运行。 Windows 驱动程序分类扩展并替换了旧的通用驱动程序分类。</p>`,10)]))}const r=s(l,[["render",e]]),d=JSON.parse('{"path":"/Study/Note/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.html","title":"进程和线程","lang":"zh-CN","frontmatter":{"description":"进程和线程 进程是资源分配的基本单位。线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。 windows进程相关 （1）当我们双击一个程序test.exe运行的时候，一定是被另一个程序（Explorer.exe:桌面进程)调用了CreateProcess函数 打开的 （2）test.exe是PE文件，CreateProcess进入内...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进程和线程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-07-13T15:23:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"灰灰烟影\\",\\"url\\":\\"http://hugo.work\\"}]}"],["meta",{"property":"og:url","content":"http://hugo.work/Study/Note/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"灰灰烟影"}],["meta",{"property":"og:title","content":"进程和线程"}],["meta",{"property":"og:description","content":"进程和线程 进程是资源分配的基本单位。线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。 windows进程相关 （1）当我们双击一个程序test.exe运行的时候，一定是被另一个程序（Explorer.exe:桌面进程)调用了CreateProcess函数 打开的 （2）test.exe是PE文件，CreateProcess进入内..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-07-13T15:23:20.000Z"}],["meta",{"property":"article:modified_time","content":"2022-07-13T15:23:20.000Z"}]]},"git":{"createdTime":1657725800000,"updatedTime":1657725800000,"contributors":[{"name":"HooYing","username":"HooYing","email":"1161844396@qq.com","commits":1,"url":"https://github.com/HooYing"}]},"readingTime":{"minutes":3.85,"words":1154},"filePathRelative":"Study/Note/进程和线程.md","excerpt":"","autoDesc":true}');export{r as comp,d as data};
